---
title: Reducer
description: Protocol for evolving state and handling side effects
---

A protocol that describes how to evolve the current state of an application to the next state, given an action, and describes what effects should be executed later by the store, if any.

## Protocol Definition

```swift
public protocol Reducer<State, Action> {
  associatedtype State
  associatedtype Action
  associatedtype Body
  
  var body: Body { get }
}
```

## Associated Types

<ParamField path="State" type="associatedtype">
  A type that holds the current state of the reducer.
</ParamField>

<ParamField path="Action" type="associatedtype">
  A type that holds all possible actions that cause the `State` of the reducer to change and/or kick off a side `Effect` that can communicate with the outside world.
</ParamField>

<ParamField path="Body" type="associatedtype">
  A type representing the body of this reducer. When you create a custom reducer by implementing the `body` property, Swift infers this type from the value returned. If you create a custom reducer by implementing `reduce(into:action:)`, Swift infers this type to be `Never`.
</ParamField>

## Properties

<ParamField path="body" type="some ReducerOf<Self>">
  The content and behavior of a reducer that is composed from other reducers. In the body of a reducer one can compose many reducers together, which will be run in order, from top to bottom.
  
  <Warning>
    Do not invoke this property directly. It is called by the Store.
  </Warning>
</ParamField>

## Methods

<ParamField path="reduce(into:action:)" type="(inout State, Action) -> Effect<Action>">
  <Warning>
    **Deprecated:** Don't invoke a reducer directly. Reducers are processed by the store. If you need to run a reducer on some child state given some child action, use a 'send' effect instead.
  </Warning>
</ParamField>

## Usage

Define a reducer by conforming to the `Reducer` protocol and implementing the `body` property:

```swift
@Reducer
struct Feature {
  struct State: Equatable {
    var count = 0
  }
  
  enum Action {
    case incrementButtonTapped
    case decrementButtonTapped
  }
  
  var body: some ReducerOf<Self> {
    Reduce { state, action in
      switch action {
      case .incrementButtonTapped:
        state.count += 1
        return .none
        
      case .decrementButtonTapped:
        state.count -= 1
        return .none
      }
    }
  }
}
```

## Composing Reducers

Reducers can be composed together in the `body` using reducer operations:

```swift
var body: some ReducerOf<Self> {
  Reduce { state, action in
    // Core logic
  }
  .ifLet(\.child, action: \.child) {
    ChildFeature()
  }
  ._printChanges()
  
  Analytics()
}
```

## Type Aliases

<ParamField path="ReducerOf" type="typealias">
  A convenience for constraining a `Reducer` conformance:
  
  ```swift
  public typealias ReducerOf<R: Reducer> = Reducer<R.State, R.Action>
  ```
  
  This allows you to specify the `body` of a `Reducer` conformance like:
  
  ```swift
  var body: some ReducerOf<Self> {
    // ...
  }
  ```
  
  Instead of the more verbose:
  
  ```swift
  var body: some Reducer<State, Action> {
    // ...
  }
  ```
</ParamField>
